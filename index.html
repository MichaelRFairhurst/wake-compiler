<!DOCTYPE html>
<html>
	<head>
		<title>Wake The Language</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
		<link rel="stylesheet" href="/highlight.js/styles/tomorrow.css">
		<script src="/highlight.js/highlight.pack.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script type="text/javascript" src="page.js"></script>
		<link rel="stylesheet" type="text/css" href="page.css">
	</head>
	<body>
		<div class="mynavbar">
				<div class="btn-group" style="width: 100%">
					<a class="btn btn-block dropdown-toggle" data-toggle="dropdown" href="#">
						Try Wake Now
						<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="https://github.com/MichaelRFairhurst/wake-compiler">View on Github</a></li>
						<li><a href="TryWake.php">Try it Online</a></li>
						<li><a href="howto.html">Local Development how-to</a></li>
					</ul>
				</div>
			<hr />
			<ul class="nav nav-tabs nav-stacked">
				<li><a href="#intro">Wake</a></li>
				<li><a href="#codeinto">Quick Code Introduction</a></li>
				<li><a href="#new">New ideas in Wake</a></li>
				<li><a href="#removals">What we removed</a></li>
				<li><a href="#trywake">Try Wake online</a></li>
				<li><a href="#variables">Variables</a></li>
				<li><a href="#typevariables">- Types as Variables</a></li>
				<li><a href="#aliases">- Aliased Variables</a></li>
				<li><a href="#shadowing">- Shadowing Types</a></li>
				<li><a href="#declarations">- Declaring Variables</a></li>
				<li><a href="#optionals">- Optional Types</a></li>
				<li><a href="#lists">- Using Lists</a></li>
				<li><a href="#classes">Classes</a></li>
				<li><a href="#dependencies">- Dependencies</a></li>
				<li><a href="#properties">- Properties</a></li>
				<li><a href="#inheritance">- Inheritance</a></li>
				<li><a href="#methods">Methods</a></li>
				<li><a href="#invoking">- Invoking Methods</a></li>
				<li><a href="#overloading">- Overloading Methods</a></li>
				<li><a href="#generics">Generics</a></li>
				<li><a href="#provisions">Provisions</a></li>
				<li><a href="#plainprovisions">- Plain Provisions</a></li>
				<li><a href="#specializedprovisions">- Specialized Provisions</a></li>
				<li><a href="#primitiveprovisions">- Providing Primitive Values</a></li>
				<li><a href="#ctorprovisions">- Constructor Provisions</a></li>
				<li><a href="#behavioralprovisions">- Behavioral Provisions</a></li>
				<li><a href="#entry">Program entry points</a></li>
			</ul>
		</div>
		<div class="opennav"><button class="btn btn-inverse btn-small"><i class="icon-align-justify icon-white"></i></button></div>
		<div class="content" data-spy="scroll" data-target=".mynavbar">
			<div class="hero-unit" id="intro">
				<h1>Wake The Language</h1>
				<p>
					Wake is a fast, expressive, typesafe language that gives you testability from the ground up.
				</p>
			</div>
			<p>Throughout the docs, we'll show you how we've made the language <span class="label label-inverse">testable</span>, <span class="label label-inverse">flexible</span>, <span class="label label-inverse">readable</span>, <span class="label label-inverse">concise</span>, and <span class="label label-inverse">safe</span>.</p>
			<hr />
			<h1 id="codeinto">Quick Code Introduction</h1>
			<p>We'll compare Wake to both java and javascript. You'll see friendly classes, clean code, and intuitive type safety.</p>
			<p>or you can <b>jump straight in:</b></p>
			<ul>
				<li><a href="#variables">How variables work</a></li>
				<li><a href="#methods">Valid method names &amp; APIs</a></li>
				<li><a href="#classes">Using classes</a></li>
				<li><a href="#provisions">Tell me about provisions</a></li>
				<li><a href="#entry">Where does the program begin?</a></li>
			</ul>
			<div class="row">
				<div class="span6">
					<h3>Wake</h3>
<div class="alert alert-success">Code as concise as javascript, with inheritance and typesafety and more</div>
					<span class="label label-info">Wake</span>
					<pre><code class="wake"
>every FibGenerator is:
    needs <span class="goodcode" title="Ask and you are guaranteed to receive a capable Printer.">Printer</span>;

    <span class="goodcode" title="The compiler lends a hand, only Nums can be returned.">Num</span> -- generate( <span class="goodcode" title="Only accept Nums, with compact syntax.">Num</span> ) {
        if(Num == 0) return 0;
        if(Num == 1) return 1;
        return <span class="goodcode" title="Compact means of calling class methods">generate</span>(Num - 1) + generate(Num - 2);
    }

    Num -- <span class="goodcode" title="A uniquely clear method naming system">sumFrom( Num )To( $Num )</span> {
        var Num sum = generate(Num);
        if(Num &gt; $Num)
            return sum + sumFrom(Num - 1)To($Num);
        else return sum;
    }

    printUpTo( Num ) {
        if(Num &gt; 0) printUpTo(Num);
        Printer.<span class="goodcode" title="Intuitive method overloading">print</span>(generate(Num));
    }</code></pre>
				</div>
				<div class="span6" id="javascript">
					<h3>Javascript / <a onclick="$('#java').show();$('#javascript').hide();">Java</a></h3>
<div class="alert alert-error">Elegant and concise, but unintiuitive, unsafe, with pitfalls all around</div>
					<span class="label label-important">Javascript</span>
					<pre><code class="javascript"
>var <span class="badcode" title="Not clearly a class definition, and in fact, isnt always a class">FibGenerator</span> = function(<span class="badcode" title="You can ask for a console, but cannot guarantee you'll get one.">console</span>) {

    <span class="badcode" title="Unintuitive method syntax.">this.generate = function</span>(<span class="badcode" title="There is no way of knowing if x is a number, or even exists at all.">x</span>) {
    	if(<span class="badcode" title="If this were misspelled (or capitalized) there would be no errors revealed until runtime.">x</span> == 0) return 0;
        if(<span class="badcode" title="Passing a string into this function is legal, and will never equal one or zero, and therefore will result in an endless loop.">x == 1</span>) return 1;
        return <span class="badcode" title="Overly verbose method calls">this</span>.generate(x - 1) + <span class="badcode" title="If generate were a private method, 'this' would be unusable, which is only revealable at runtime.">this</span>.generate(x - 2);
    }

    this.sumFromRange = function(top, bot) {
        <span class="badcode" title="The var keyword is easily forgotten, resulting in overwriting global variables.">var</span> sum = <span class="badcode" title="Unsafe. Generate can be redefined to any function with any return type.">this.generate</span>(top);
        if(top &gt; bot)
            return sum <span class="badcode" title="If either operand returns strings, the result is '12' rather than '3'.">+</span> this.sumFromRange(top - 1, bot);
        else return sum;
    }

    this.printUpTo = function(x) {
        if(x &gt; 0) this.printUpTo(x);
    	<span class="badcode" title="No compiler warning for using a console that may not exist.">console.log</span>(this.generate(x));
    }
}</code></pre>
				</div>
				<div class="span6" style="display:none" id="java">
					<h3><a onclick="$('#java').hide();$('#javascript').show();">Javascript</a> / Java</h3>
<div class="alert alert-error">Powerful and typesafe at the expense of clunky boilerplate</div>
					<span class="label label-important">Java</span>
					<pre><code class="java"
>class FibGenerator {

    <span class="badcode" title="Part one of three in requiring a printer. Verbose, and ultimately our printer may still be null.">private Printer printer;</span>

    <span class="badcode" title="Allowing public constructors enables the untestable and unnecessary singleton pattern.">public</span> <span class="badcode" title="Unintuitive constructor syntax.">FibGenerator</span>(<span class="badcode" title="Repetitive type declaration">Printer</span> <span class="badcode" title="Meaningless name creation to keep myprinter distinct from printer">myprinter</span>) {
        <span class="badcode" title="Step three in requiring a printer">printer = myprinter</span>;
    }

    <span class="badcode" title="No convention over configuration, public and private must always be specified.">public</span> int generate(<span class="badcode" title="verbose type systems can encourage programmers to use uninformative names like 'x'">int x</span>) {
        if(x == 0) return 0;
        if(x == 1) return 1;
        return generate(x - 1) + generate(x - 2);
    }

    public int sumFromRange(int top, int bot) {
        <span class="badcode" title="Declarations can at any point be overriding previous declarations, making the original variable unusable until scope ends, often with no compiler error.">int sum</span> = generate(top);
        if(top &gt; bot)
            return sum + sumFromRange(top - 1, bot);
        else return sum;
    }

    public void printUpTo = function(int x) {
        if(x &gt; 0) printUpTo(x);
        myprinter.print(this.generate(x).<span class="badcode" title="Casting strings and ints can take micromanaging from the programmer.">toString</span>());
    }</code></pre>
				</div>
			</div>
			<hr />
			<h1 id="new">New ideas in Wake</h1>
			<p>We've both created and borrowed some cutting edge ideas.</p>

			<div class="row">
				<div class="span3">
					<h4>Provisions</h4><span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span>
				</div>
				<div class="span5">
					<br /><blockquote>Use provisions to keep a testable and extensible seam between every class.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success">This makes testability and flexibility a language feature.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Type Inference</h4><span class="label label-inverse">concise</span>
				</div>
				<div class="span5">
					<br /><blockquote>Keep the expressive, clean look of dynamic languages, with a safe type system.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success">This saves you time writing, reading, and refactoring code.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Constructor Properties</h4><span class="label label-inverse">testable</span> <span class="label label-inverse">concise</span>
				</div>
				<div class="span5">
					<br /><blockquote>Reduce boiler-plate code by making constructor arguments exactly like properties.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success">This makes best practices like Aspect-Oriented-Programming intuitive.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Two-way polymorphism</h4><span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span>
				</div>
				<div class="span5">
					<br /><blockquote>Eventually will add this.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success">This creates testable inheritance by increasing expressive object design.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Compilation targets as a language feature</h4><span class="label label-inverse">flexible</span>
				</div>
				<div class="span5">
					<br /><blockquote>A goal of Wake is to compile into anything -- .net, java, javascript, and assembly</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success">This makes Wake libraries usable in every one of your projects.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Closures</h4><span class="label label-inverse">flexible</span> <span class="label label-inverse">concise</span>
				</div>
				<div class="span5">
					<br /><blockquote>Wake is part of a small class of strongly-typed, object oriented languages with functional coloring.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success">This adds concise, elegant, rapid-development to your scalable enterprise apps.</div>
				</div>
			</div>

			<hr />

			<h1 id="removals">What Wake did without</h1>
			<p>Any poor feature in a language can prevent the addition of a powerful one. We made some hard choices to create a strong cocktail of ideas.</p>
			<table class="table">
				<tr>
					<th>What we cut</th>
					<th>Why we cut it</th>
					<th>What it enabled</th>
				</tr>
				<tr>
					<td><b>Static methods</b></td>
					<td><div class="alert alert-error">Using a static method from a procedure hard-codes implementation rather than interface, decreasing flexibility and testability</div></td>
					<td><span class="label label-success">FIXED</span> You can (and usually should) now use exact type names as variable names, meaning more clarity and fewer keystrokes.</td>
				</tr>
				<tr>
					<td><b>The <code>new</code> keyword</b></td>
					<td><div class="alert alert-error"><code>new</code> mixes application APIs with implementations, and has been replaced with 'provisions.'</div></td>
					<td><span class="label label-success">FIXED</span> Constructors directly translate to properties since they are not functions.</td>
				</tr>
				<tr>
					<td><b>Interface/extension distinction</b></td>
					<td><div class="alert alert-error">A common best practice is to create an interface for every class, even before its used, resulting in junk code and extra boilerplate.</div></td>
					<td><span class="label label-success">FIXED</span> In Wake you can use any class as an interface, making everything driven by APIs without any additional code.</td>
				</tr>
				<tr>
					<td><b>Abstract classes</b></td>
					<td><div class="alert alert-error">Abstract classes are a combination of an interface and a class, or a means of locking a class to static methods.</div></td>
					<td><span class="label label-success">FIXED</span> We let the compiler tell you if a class is incomplete, not vice versa, without any management on your part.</td>
				</tr>
				<tr>
					<td><b>Primitive types</b></td>
					<td><div class="alert alert-error">Primitive types are fast, but without methods they require external behavior to manipulate them.</div></td>
					<td><span class="label label-success">FIXED</span> The compiler handles autoboxing primitives into objects - <code>Num</code>, <code>Bool</code>, <code>Text</code>, etc - and lets you code without managing the conversion.</td>
				</tr>
				<tr>
					<td><b>Cryptic keywords</b></td>
					<td><div class="alert alert-error"><code>Abstract</code>, <code>virtual</code>, <code>volatile</code>, and other cryptic keywords from the 1970s convey very little about what they actually do.</div></td>
					<td><span class="label label-success">FIXED</span> New programmers will find every keyword to be simple, and meaningful, from <code>Truth</code> to <code>Text</code> to <code>capable</code>.</td>
				</tr>
			</table>

			<div class="hero-unit" id="trywake">
				<h1 id="trywake">Try Wake Online</h1>
				<p>We handled installing it for you, and with javascript as a compile target, you can run it all right in your browser</p>
				<h3><a href="TryWake.php">Try Wake Online</a></h3>
			</div>

			<hr />

			<h1 id="variables">Making The Most Of Wake Variables</h1>
			<div class="alert alert-success">Variables in Wake come in three forms, all with the goal of meaningful names in minimal keystrokes.</div>
			<h3 id="typevariables">1. Typenames as variables <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h3>
			<p>Since we got rid of static methods, we can save you from repeating yourself meaninglessly in domain-driven code.</p>
			<div class="row">
				<div class="span6">
					<span class="label label-info">Wake</span>
					<pre><code class="wake"
>every Person is:

    needs <span class="goodcode" title="You can tell the compiler its an int called ID, or, when you want, simply call it an Num.">Num</span>;

    Num -- getId() {
        return <span class="goodcode" title="Here we use our Num ID, that we simply chose to call 'Num.'">Num</span>;
    }

    Truth -- isSameAs(<span class="goodcode" title="Save yourself writing 'Person' twice, and you get the benefit of <i>knowing</i> that Person is a Person.">Person</span>) {
        return getId() == <span class="goodcode" title="Clear, concise, and the programmer knows the type as well as the compiler.">Person</span>.getId();
    }</code></pre>
				</div>
				<div class="span6">
					<span class="label label-important">Java</span>
					<pre><code class="java"
>class Person {

    private <span class="badcode" title="Here we must say its an int, and even though that is often enough to make it unique, we must also name it.">int id</span>;

    public Person(int <span class="badcode" title="Here we have made a useless name to explain that this is not the same Num as the property. The programmer juggles what this means and determines it is a useless distinction.">myid</span>) {
        id = myid;
    }

    public int getId() {
        return id;
    }

    public bool isSameAs(<span class="badcode" title="Here we write this out twice for no good reason, or we name it something else when we only truly care that this variable is a Person.">Person person</span>) {
        return getId() == <span class="badcode" title="This looks almost exactly like a static method call, meaning descriptive variable names can actually create confusion.">person</span>.getId();
    }
}</code></pre>
				</div>
			</div>
			<h3 id="aliases">2. Aliasing <span class="label label-inverse">readable</span> <span class="label label-inverse">safe</span></h3>
			<p>In our previous example, calling a person's ID <code>Num</code> is a bit ambiguous. When a type isn't meaningful for a context, use aliases.</p>
			<p>To aid the compiler, we must write aliases in lowercase, to hint that its not a type. But luckily, it turns out that the same idea is useful to humans as well. It also allows us to write aliases before or after our type to make our code more literate.</p>
			<div class="row">
				<div class="span6">
					<span class="label label-info">Wake</span>
					<pre><code class="wake"
>every Person is:

    needs Num <span class="goodcode" title="Here we give our Num a name.">id</span>;

    Num -- getId() {
        return <span class="goodcode" title="Here we use our Num by its alias, id. We know that it is not a typename.">id</span>
    }

    setIdThenSave(<span class="goodcode" title="You can precede variables with aliases.">newid Num</span>, <span class="goodcode" title="You can also precede variables by their type.">Truth recursively</span>) {
        ...
    }</code></pre>
				</div>
				<div class="span6">
					<span class="label label-important">Java</span>
					<pre><code class="java"
>class Person {

    private int id;

    public Person(int myid) {
        id = myid;
    }

    public int getId() {
        return id;
    }

    public void setIdThenSave(<span class="badcode" title="Sometimes functions read better with types first or second, but you have no choice.">int id</span>, bool recursively) {
        //...
    }
}</code></pre>
				</div>
			</div>
			<h3 id="shadowing">3. Shadowing <span class="label label-inverse">concise</span> <span class="label label-inverse">safe</span></h3>
			<p>Following from the idea that the most meaningful name for a variable often <i>is</i> its type, we have a problem with places like 'setter' methods. The new value is of the same type as the old value, but they must be distinguished.</p>
			<p>Instead of creating meaningless aliases as we arguably did with <code>newid</code>, we can add <code>$</code> to preserve type information while also creating a unique instance</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every NumContainer is:

    needs Num;

    Num -- setToNotGreaterThan(<span class="goodcode" title="Here, all we really care about is that Num and $Num are different variables; we don't force you to come up with a unique name.">$Num</span>) {
        if(Num &gt; <span class="goodcode" title="While this can be confusing, this is a usage of $Num the argument rather than Num the property. We let you decide when its appropriate, such as short statements and algorithms.">$Num</span>) Num = $Num;
    }</code></pre>
			<h3 id="declarations">Declaring variables <span class="label label-inverse">concise</span> <span class="label label-inverse">safe</span></h3>
			<p>All these variable names are usable in declarations when preceded with <code>:</code>, or when in properties</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every DeclarationExample is:

    <span class="goodcode" title="Here we define an object property.">with Num here = 4;</span>
    with some Num = 4;
    with $Num = 4;
    <span class="goodcode" title="Properties can be public.">with public Num too = 5;</span>

    <span class="goodcode" title="Here we define dependencies.">needs another Num, $$Num, Num again;</span>

    declareThem() {
        <span class="goodcode" title="Here we define variables within a method.">var local Num = 4;</span>
        var second Num = 4;
        var $$$Num = 5;
        <span class="badcode" title="Compiler error! In Wake you cannot redefine variables.">var Num = 3</span>;
    }</code></pre>

			<h3 id="optionals">Optional Types <span class="label label-inverse">typesafe</span></h3>
			<p>Wake will guarantee the existence of most variables, arguments, and return types. This prevents rogue NullPointerExceptions, or segfaults, or fatal errors that large apps in other languages frequently succumb to.</p>
			<p>The flip side to this is that when a value may not exist, it must be declared <i>optional</i> with <code>?</code>. Before using an optional type, the compiler ensures you have accounted for the possibility of it not existing with <code>exists</code> clauses.</p>
			<pre><code class="wake"
>every OptionalTypeUsage is:

    Num? -- mayReturnAnNumAndAcceptsAn(Num?) {
        <span class="goodcode" title="You can always assign a real type to an optional one.">Num = 5;</span>
        <span class="goodcode" title="You can always set an optional type to Nothing.">Num = Nothing;</span>
        <span class="goodcode" title="This checks if Num is not Nothing. Inside this block, Num is no longer an optional type.">if Num exists {</span>
            return Num + 7;
        } else {
            return Nothing;
        }
    }
</code></pre>
			<h3 id="lists">Using Lists <span class="label label-inverse">typesafe</span></h3>
			<div class="alert alert-error">
				Until further releases, reading an unassigned list index results in undefined behavior, like in C/C++. Later on it will throw exceptions.
			</div>
			<p>Lists (called Arrays in many other languages) are a way of storing sets of a particular type. They are incredibly useful.</p>
			<pre><code class="wake"
>every ListUsage is:

    methodWithListArgument(<span class="goodcode" title="Here we accept a list of Nums">Num[]</span>) {
        <span class="goodcode" title="Set the first Num in the list.">Num[0] = 5;</span>
        <span class="goodcode" title="Declare an empty list of Nums again.">var $Num[] = [];</span>
        <span class="goodcode" title="Declare a list of Nums again, except with three starting values.">var $$Num[] = [1, 2, 3];</span>
        <span class="goodcode" title="Declare a list lists of Nums, containing our lists of ints.">var combined $Num[][] = [Num[], $Num[], $$Num[]];</span>
    }</code></pre>
			<hr />
			<h1 id="classes">Classes in Wake <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h1>
			<p>Wake is a truly Object Oriented language, and should come with few surprises here.</p>
			<p>In Wake, everything is an object. A class declaration begins with the keyword <code>every</code> as seen below. Within that definition can be properties, dependencies, a constructor, methods, and provisions.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every MyClass is:
    <span class="goodcode" title="Here we have an object property.">with public Text name;</span>
    <span class="goodcode" title="Properties default to private.">with Text ssn;</span>

    needs <span class="goodcode" title="Here we have dependencies. The object cannot exist without them.">Num id, Printer</span> then {
        <span class="goodcode" title="You can declare 'needs nothing then {...} to have a constructor with no dependencies.">// constructor body</span>
    }

    <span class="goodcode" title="Provisions; the details are in their own section.">provides Text:URL &lt;- 'http://www.wakelang.com';</span>

    <span class="goodcode" title="A method declaration.">Text -- getSSNLastFour() {</span>
        // ...
    }</code></pre>
			<h3 id="dependencies">Dependencies <span class="label label-inverse">concise</span> <span class="label label-inverse">testable</span></h3>
			<p>When an object is constructed, first the dependencies are all resolved by means of provisions. This means that you can simply say your object <code>needs Printer</code>, and you will always have one.</p>
			<pre><code class="wake"
>every FileStream is:
    needs Text filename, <span class="goodcode" title="needs can be public properties, too.">public OutStream;</span></code></pre>
			<h3 id="properties">Properties <span class="label label-inverse">flexible</span></h3>
			<p>At this point the object has its dependencies met, and each property can use the needs in their initialization. Then the constructor is called.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every IncrementingProperties is:
    needs Num starter, Printer {
        Printer.print(<span class="goodcode" title="By now, the property sum exists.">sum</span>);
    }

    with Num <span class="goodcode" title="When plusone is declared, starter already exists since its a dependency.">plusone = starter + 1;</span>
    with Num <span class="goodcode" title="Since plustwo is declared after plusone, we can use it to evaluate its initial value.">plustwo = starter + 2;</span></code></pre>
			<h3 id="inheritance">Inheritance <span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span> <span class="label label-inverse">readable</span></h3>
			<p>Every class can be inherited with or without keeping behavior, with the keywords <code>a</code>/<code>an</code>, and <code>capable</code>. Usually in small projects the point of inheritance is to copy the code from that class, however, it is not always desirable. If you use <code>capable</code>, you must rewrite the methods of your child class. These actions are called <i>extending</i> vs <i>implementing</i>.</p>
			<p>An additional value to implementing classes with <code>capable</code> instead of extending classes with <code>a</code>/<code>an</code>, is that you can implement multiple classes even though you can only extend one class.</p>
			<p>An object which extends or implements another class can be used as that subclass elsewhere in the code.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every BaseClass is:

    myMethod(Printer) {
        Printer.print("BaseClass");
    }

every SubClass (<span class="goodcode" title="Subclass extends BaseClass, meaning SubClass can use myMethod off of BaseClass.">a BaseClass</span>, <span class="goodcode" title="We implement Printer, meaning we must declare the method print().">capable Printer</span>) is:

    needs Printer;

    <span class="goodcode" title="Here we define Printer.print() so we can be a capable printer.">print(Text)</span> {
       Printer.print("SubClass printing: " + Text);
    }

    <span class="goodcode" title="Running this method will output &quot;SubClass printing: BaseClass&quot;">useThisAsPrinter</span>() {
        <span class="goodcode" title="Use BaseClass.myMethod since SubClass is a BaseClass. You can also do this with parent.myMethod()">myMethod</span>(<span class="goodcode" title="We can send 'this' as the argument of myMethod(Printer) since SubClass is a capable Printer.">this</span>);
    }</code></pre>
			<hr />
			<h1 id="methods">Valid Methods in Wake <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h1>
			<div class="alert alert-info">
				Methods in Wake can look strange at first. The changes are simple and make your APIs read like sentences.
			</div>
			<p>In java, a detailed method signature may look like <code>addExaminerToContractWithMedicalCompany(Examiner examiner, MedicalCompany company)</code>. We decided we can do better. In Wake you could rewrite that method as <code>add( Examiner )ToContractWith( MedicalCompany )</code>. Here are some examples:</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every MethodExample is:
    ReturnType -- methodWithReturn() {}
    methodWithNoReturnValue() {}
    abstractMethodWithNoImplementation();
    methodWithArgument(Num) {}
    methodWithArgument(this Num) {}
    methodWithArgument(Num here) {}
    methodWith(Num)ArgumentAnd(Text)Argument() {}</code></pre>
			<h3 id="invoking">Invoking Methods <span class="label label-inverse">readable</span></h3>
			<p>Invoking methods (that is, calling a method's code on a particular object and argument set) looks almost exactly like defining one.</p>
			<pre><code class="wake"
>every MethodInvoker is:

    methodWithArgument(Truth) {
        <span class="goodcode" title="Now that we've defined methodWithArgument(Truth), we invoke it inside a Wake statement.">methodWithArgument(!Truth);</span>
    }</code></pre>
		<h3 id="overloading">Method Overloading <span class="label label-inverse">readable</span> <span class="label label-inverse">concise</span></h3>
		<div class="alert alert-error">Method overloading can create more confusion than it prevents. It may be removed from Wake in the future.</div>
		<p>Method overloading exists in C++ and java. A method can accept differently typed objects, and have different behaviors for each. Used properly, it creates shorter method names that focus on behavior rather than implementation.</p>
		<pre><code class="wake"
>every CrossTypeComparator is:
    Truth -- compare( Text )And( $Text ) {
        <span class="goodcode" title="Here we can write code that returns if a Text comes alphabetically before another.">//...</span>
    }

    Truth -- compare( Num )And( $Num ) {
        <span class="goodcode" title="Here we can write code that returns if an Num is less than the other.">return Num &lt; $Num;</span>
    }</code></pre>
		<hr />
		<h1 id="provisions">Provisions <span class="label label-inverse">flexible</span> <span class="label label-inverse">testable</span> <span class="label label-inverse">typesafe</span></h1>
		<p>Testability was a huge goal of Wake's design. We were inspired by dependency injection frameworks to make a faster, typesafe means of binding dependencies to behavior. What we came up with is provisions.</p>
		<p>What in other languages may be a static method, or a call to <code>new</code> another object, or a helper function call, instead is fetched from a provider. Here we look at how.</p>
		<pre><code class="wake"
>every UsesProvider is:

    needs <span class="goodcode" title="This dependency will be provided by whatever provision made our UsesProvider object.">Provider</span>, <span class="goodcode" title="We can mark provisions with labels matched at compile time.">DependentClass:Special</span> then {
        <span class="goodcode" title="This is just syntactic sugar, it takes a Printer from our provider and assigns it to the variable Printer.">var Printer &lt;- Provider;</span>
        <span class="goodcode" title="Here a printer is fetched from our Provider object, but not assigned to a variable.">(Printer &lt;- Provider)</span>.print(Text);
    }</code></pre>
		<h3 id="generics">Generics <span class="label label-inverse">flexible</span> <span class="label label-inverse">typesafe</span></h3>
		<p>Like Java, C#, and other languages, wake supports generic types.</p>
		<div class="alert alert-info">Generics are required for a powerful static type system. Unlike wake, Java and C# did not have generics in early versions. As such, the type safety and performance of arrays in these languages was thrown out to accomodate missing flexibility. Wake had generics from version one and does not suffer these drawbacks.</div>
		<div class="alert alert-info">The wake syntax uses curly braces instead of angle brackets for generics. This simple difference speeds up compilation and makes parsing easier for independent programs, as it is a 100% context-free grammar.</div>
		<div class="alert alert-error">These examples use function types that are not yet implemented.</div>
		<pre><code class="wake"
>every CalculationCache<span class="goodcode" title="A calculation cache holds a value of any type T.">{T}</span> is:
    with <span class="goodcode" title="This may hold an integer, text, a class, or even yet another calculation cache. Calling code decides.">T?</span> = <span class="goodcode" title="Begin the cache as empty">nothing</span>;
    needs <span class="goodcode" title="Store the function to calculate the value">T -- fn()</span> calculation;
    <span class="goodcode" title="Here we provide the calculated value of type T.">T</span> -- getValue() {
        if(<span class="goodcode" title="Use our type T by its typename since it was not aliased.">T</span> == nothing) {
            T = calculation();
        }
        return T;
    }</code></pre>
	<p>The type information of a generic is deffered until the moment where its used. For those unfamiliar with generics, using one would look like this.</p>
		<pre><code class="wake"
>every Squarer is:
    needs Num;
    provides <span class="goodcode" title="Specific variations of generics can be properties, provisions, needs, and more.">CalculationCache{Num};</span>
    with CalculationCache{Num} <span class="goodcode" title="Create a calculation cache that squares Num">&lt;(Num -- fn() { return Num * Num; }) this;</span>
    Num -- get() {
        return CalculationCache.getValue();
    }</code></pre>
		<h3 id="plainprovisions">Defining Plain Provisions <span class="label label-inverse">concise</span> <span class="label label-inverse">typesafe</span></h3>
		<p>A plain provision simply marks that your class can provide a type. The compiler will ensure that you can provide all of that type's dependencies as well.</p>
		<pre><code class="wake"
>every Provider is:

    provides <span class="goodcode" title="As in UsesProvider above, this means anywhere you have a Provider you can get a Printer from it.">Printer</span>, OtherClass;</code></pre>

		<h3 id="subtypeprovisions">Providing Subtypes <span class="label label-inverse">flexible</span> <span class="label label-inverse">testable</span> <span class="label label-inverse">typesafe</span></h3>
		<p>The point of provisions is to make all dependencies or created objects be replacable with subtypes, at the creator's discretion. This is called Inversion Of Control. You can provide mock objects for testing, easily swap logging methods, and more.</p>
		<pre><code class="wake"
>every Provider is:

    provides Printer &lt;- <span class="goodcode" title="Easily suppress output of your application by swapping one class">DisabledPrinter</span>;</code></pre>

		<h3 id="specializedprovisions">Specialized Provisions <span class="label label-inverse">typesafe</span> <span class="label label-inverse">flexible</span></h3>
		<p>Sometimes a classname is not detailed enough to know your dependencies will be properly provided. Using what we call Specialties, you can provide and require specific objects.</p>
		<pre><code class="wake"
>every DBProvider is:

    provides
        <span class="goodcode" title="This is just a plain provision.">User</span>,
        <span class="goodcode" title="Here we provide a connection by name Default. Note that this is still a plain provision. This is required since we provide User.">DBConnection:Default</span>;

every User is:

    needs <span class="goodcode" title="Here we require the Default DBConnection.">DBConnection:Default</span>;</code></pre>
		<h3 id="primitiveprovisions">Primitive Provisions <span class="label label-inverse">typesafe</span></h3>
		<p>Primitive provisions cannot be plain, since the compiler can't tell you what Num to provide. Additionally, they must be specified, to ensure you get the right value. These are the equivalent of constants in Wake, and bind directly to a primitive value.</p>
		<pre><code class="wake"
>every PrimitiveProvider is:

    provides Text:Username &lt;- "MyUser", Num:Port &lt;- 3306;</code></pre>

		<h3 id="ctorprovisions">Constructor Provisions <span class="label label-inverse">flexible</span></h3>
		<p>We call this constructor provision since it most closely resembles constructors in languages like Java. However, it is merely a way of matching provisions to specific dependencies.</p>
		<pre><code class="wake"
>every Provider is:
    provides
        Num:Port &lt;- 3307,
        Text:Username &lt;- "Test",
        DBConnection:Test &lt;- DBConnection(<span class="goodcode" title="If a DBConnection accepts any Text username, we can create specialized connections by letting the provider find the right Username and Port.">Text:Username, Num:Port</span>),
		<p>If a class with needs extends another class with needs, constructor provisions require that you supply all of these. When doing this, supply the childclass needs first, and then the parent class needs, in that order. And don't worry, the compiler will make sure you don't mess up.</p>
        <span class="goodcode" title="Constructor provisions do not require specialization.">User</span> &lt;- <span class="goodcode" title="Constructor provisions can be used with subtype provision simultaneously.">TestUser</span>(DBConnection:Test);</code></pre>
		<h3 id="behavioralprovisions">Behavioral Provisions <span class="label label-inverse">flexible</span></h3>
		<div class="alert alert-error">These are not supported quite just yet.</div>
		<p>Provisions can be treated as a code body with a return type where necessary. Note that the end result must be a provision; however it can be used to configure objects or provide different objects conditionally, or create a singleton.</p>
		<pre><code class="wake"
>every Provider is:

    needs <span class="goodcode" title="Require an unconfigured session.">Session</span> then {
        Session.<span class="goodcode" title="Configure our Session so it is provided properly">loadFile</span>(<span class="goodcode" title="Retrieve our own SessionFile path">Text:SessionFile &lt; this</span>);
    }

    provides
        Text:SessionFile,
        Session &lt;- <span class="goodcode" title="This, together with our constructor, guarantees that we only distribute one session, and that its been properly loaded.">{ return Session; }</span>;</code></pre>
		</div>
		<script src="bootstrap/js/bootstrap.min.js"></script>
	</body>
</html>
