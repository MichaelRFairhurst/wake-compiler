<!DOCTYPE html>
<html>
	<head>
		<title>Wake The Language</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
		<link rel="stylesheet" href="/highlight.js/styles/tomorrow.css">
		<script src="/highlight.js/highlight.pack.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script type="text/javascript" src="page.js"></script>
		<link rel="stylesheet" type="text/css" href="page.css">
	</head>
	<body>
		<div class="mynavbar">
			<ul class="nav nav-tabs nav-stacked">
				<li><a href="#installing">Installing</a></li>
				<li><a href="#firstprogram">A First Program</a></li>
				<li><a href="#compiling">Compiling</a></li>
				<li><a href="#stdlib">Standard Library</a></li>
				<li><a href="#num">- Num</a></li>
				<li><a href="#text">- Text</a></li>
				<li><a href="#bool">- Bool</a></li>
				<li><a href="#list">- List</a></li>
				<li><a href="#Map">- Map{K,V}</a></li>
				<li><a href="#printer">- Printer</a></li>
				<li><a href="#FileSystem">- FileSystem</a></li>
				<li><a href="#FilePath">- FilePath</a></li>
				<li><a href="#File">- File</a></li>
				<li><a href="#Argv">- Argv</a></li>
				<li><a href="#System">- System</a></li>
				<li><a href="#knownisssues">Known Issues</a></li>
				<li><a href="#optionalarrays">- Optional Arrays</a></li>
				<li><a href="#nestedoptionals">- Nested Optionals</a></li>
				<li><a href="#genericprops">- Generic Properties</a></li>
				<li><a href="#overlappinggenerics">- Overlapping Generics</a></li>
				<li><a href="#missingfeats">Missing Features + Workarounds</a></li>
				<li><a href="#ctorargs">- Constructor Arguments</a></li>
				<li><a href="#parentmethods">- Parent Method Calls</a></li>
				<li><a href="#commonclass">- Common Object Class</a></li>
				<li><a href="#publicneeds">- Public Needs</a></li>
				<li><a href="#lvaluesexist">- Exists on some L-Values</a></li>
				<li><a href="#namespaces">- Namespaces</a></li>
				<li><a href="#nothingargs">- "Nothing" as an Argument</a></li>
				<li><a href="#arrayliterals">- List Literals</a></li>
				<li><a href="#genericprovs">- Generic Provisions</a></li>
				<li><a href="#genericinheritance">- Generic Inheritance</a></li>
				<li><a href="#genericmethods">- Generic Methods</a></li>
				<li><a href="#genericranges">- Generic Ranges</a></li>
				<li><a href="#switchcase">- Switch/Case</a></li>
				<li><a href="#behavioralprovisions">- Behavioral Provisions</a></li>
				<li><a href="#abstractprovisions">- Abstract Provisions</a></li>
				<li><a href="#reflection">- Reflection</a></li>
				<li><a href="#exceptions">- Exceptions</a></li>
				<li><a href="#enums">- Enums</a></li>
				<li><a href="#recursiveimports">- Recursive Imports</a></li>
			</ul>
		</div>
		<div class="opennav"><button class="btn btn-inverse btn-small"><i class="icon-align-justify icon-white"></i></button></div>
		<div class="content" data-spy="scroll" data-target=".mynavbar">
		<div class="inner-content">
			<div class="hero-unit" id="intro">
				<h1>Wake The Language</h1>
				<p>
					Wake is a fast, expressive, typesafe language that gives you testability from the ground up.
				</p>
			</div>

			<h1 id="installing">Installing</h1>
			<p>first you need to <a href="installing.html">install wake</a>.</p>

			<h1 id="firstprogram">A first program</h1>
			<p>Begin by cloning the git project seed with the command <code>git clone http://github.com/MichaelRFairhurst/wake-project-seed.git</code>. It will create a project with the following directory structure:</p>
			<pre>
~/projects
  └──YourFirstProject/
     ├──bin/
     │  ├──obj/
     │  │  └──{compiled files here}
     │  └──tables/
     │     └──{stlib tables and your tables here}
     ├──lib/
     │  ├──obj/
     │  │  └──{3rd party library objects here}
     │  └──tables/
     │     └──{3rd party library tables here}
     ├──src/
     └──test/
</pre>
			<p>All you need to do is run <code>make</code> from this directory to build and test your code. Test files go in the test directory and source files go in src. So lets start writing code!</p>
			<span class="label label-info">Main.wk</span>
			<pre><code class="wake"
>import Printer;
import Hello;

every Main is:

    provides Hello,
        Printer,
        Text:HelloText &lt;- "dependency injection!";

    theMainMethod() {
        var Hello &lt;- this;
        Hello.hello();
    }</code></pre>
			<p>First of all, we use standard importing to get both the standard library's Printer, and secondly we import our own file Hello.wk (which we haven't written yet)</p>
			<p><code>every Main is:</code> is a basic class definition. We define a class named Main, and then in it we say our Main can construct our class <code>Hello</code>. The other stuff we provide here is stuff needed by the class Hello. If we forgot to include it, the compiler would tell us to.</pre>
			<p>In <code>theMainMethod()</code> we say <code>var Hello &lt;- this;</code>, which creates a Hello using our Main object, and assigns it to a variable named <code>Hello</code>. Then we can say <code>Hello.hello()</code> to call methods on it.</p>
			<span class="label label-info">Hello.wk</span>
			<pre><code class="wake"
>import Printer;

every Hello is:

    needs Printer, Text:HelloText;

    hello()
        Printer.printLine("Hello " + Text);
    }</code></pre>
		<p>Once again we import Printer, and once again we have a class definition - <code>every Hello is:</code>. However, this time we do not <code>provide</code> objects, but rather, we <code>need</code> them.</p>
		<p>These relate one-to-one with Main. Because Hello needs a Printer, Main provides one. But we also need <code>Text:HelloText</code>. This is an injected Text identified by a custom name. We called it <code>HelloText</code>.</p>
		<p>As you can see in the method <code>hello()</code>, our needs are not only types, but also variables. We can use <code>Printer</code> like a variable, and we print "Hello" added to our variable <code>Text</code> (the :HelloText portion is only used for dependency injection). Its a simple example of how Hello does not know how its printing, and it does not know what it's saying Hello to. This is simple Dependency Injection.<p>
		<p>As you might expect, this program will print "Hello dependency injection!". But we have to compile it first!</p>
		<Br/>

		<h1 id="compiling">Compiling</h1>
		<div class="alert-warning">Note: this section is no longer necessary to read. Simply running <code>make</code> will rebuild and retest all out-of-date files if you cloned the wake project seed.</div>
		<p>To compile a wake program, we have to compile each file separately and then link them all together in the end. Additionally, at the moment, we have to be careful about the order we compile things in. Each file you compile needs to know the table directory to read & write from. The linker stage needs to know where your program begins, requiring the table directory, and where to find the standard library.</p>
		<p>In the wake compiler source code, we automatically compile the standard library and some test files. It uses the program <code>make</code> to manage compilation order and rebuilding stale files. If you know make, it pairs well with wake.</p>
		<p>If you don't know or don't want to use make, then either run these commands by hand or put them in a script.</p>
		<pre>
wake -d bin/tables -o bin/obj/Hello.o src/Hello.wk
wake -d bin/tables -o bin/obj/Main.o src/Main.wk
wake -l -d bin/tables ~/wake/installation/stdlib.o bin/obj/Hello.o bin/obj/Main.o -o bin/YourFirstProgram.js --mainclass Main --mainmethod 'myMainMethod()'
</pre>
		<p>You can use <code>-c</code> instead of <code>--mainclass</code>, and <code>-m</code> instead of <code>--mainmethod</code> if you'd like, and if you start at <code>Main.main()</code> you can skip these options entirely. Eventually most all of these command switches will have default values like this.</p>

				<h1 id="stdlib">Standard Library</h1>
				<p>There isn't much development on the standard library yet.</p>
				<br/>
				<h3 id="num">Num</h3>
				<p><code>Text -- toString()</code></p>
				<p>&nbsp;&nbsp; Convert a number into its Text equivalet. Example: <code>5.toString(); // "5"</code></p>
				<p><code>Num -- modulo(Num)</code></p>
				<p>&nbsp;&nbsp; Get the remainder from division. Example: <code>5.modulo(2); // 1</code></p>
				<p><code>Num -- floor()</code></p>
				<p>&nbsp;&nbsp; Round down to the nearest integer. Example: <code>5.9.floor(); // 5</code></p>
				<p><code>Num -- round()</code></p>
				<p>&nbsp;&nbsp; Round to the nearest integer. Example: <code>5.5.round(); // 6</code></p>
				<p><code>Num -- ceil()</code></p>
				<p>&nbsp;&nbsp; Round up to the nearest integer. Example: <code>5.1.ceil(); // 6</code></p>
				<p><code>Num -- squared()</code></p>
				<p>&nbsp;&nbsp; Take the number to the second power. Example: <code>4.squared(); // 16</code></p>
				<p><code>Num -- abs()</code></p>
				<p>&nbsp;&nbsp; Get the absolute value of the number. Example: <code>-4.abs(); // 4</code></p>
				<p><code>Num -- orMaxOf(Num)</code></p>
				<p>&nbsp;&nbsp; Return the argument Num if greater than the target number, otherwise return the target number. Example: <code>5.orMaxOf(8); // 8</code></p>
				<p><code>Num -- orMaxOf(Num[])</code></p>
				<p>&nbsp;&nbsp; Return the largest number in the list, or the number itself if it is larger than each element in the list. Example: <code>5.orMaxOf([2, 5, 8]); // 8</code></p>
				<p><code>Num -- orMinOf(Num)</code></p>
				<p>&nbsp;&nbsp; Return the argument Num if less than the target number, otherwise return the target number. Example: <code>5.orMinf(8); // 5</code></p>
				<p><code>Num -- orMinOf(Num[])</code></p>
				<p>&nbsp;&nbsp; Return the smallest number in the list, or the number itself if it is smaller than each element in the list. Example: <code>5.orMinOf([2, 5, 8]); // 2</code></p>
				<p><code>Num -- numberOfDigits()</code></p>
				<p>&nbsp;&nbsp; Count how many digits are in the number. Example: <code>123.numberOfDigits(); // 3</code></p>
				<p><code>Num -- range(Num)</code></p>
				<p>&nbsp;&nbsp; Return a list of each number including and up to the argument, beginning at the target number. Example: <code>5.range(8); // [5, 6, 7, 8]</code></p>
				<br/>
				<h3 id="text">Text</h3>
				<p><code>Text -- toUpper()</code></p>
				<p>&nbsp;&nbsp; Get the all uppercase equivalent of the target text. Example: <code>"Hello".toUpper(); // "HELLO"</code></p>
				<p><code>Text -- toLower()</code></p>
				<p>&nbsp;&nbsp; Get the all lowercase equivalent of the target text. Example: <code>"Hello".toLower(); // "hello"</code></p>
				<p><code>Text -- switchCase()</code></p>
				<p>&nbsp;&nbsp; Swap the casing of each charecter in the target text. Example: <code>"Hello".switchCase(); // "hELLO"</code></p>
				<p><code>Text -- trim()</code></p>
				<p>&nbsp;&nbsp; Remove whitespace (tabs, newlines, spaces, etc) from  the beginning and ending of the Text. Example: <code>"  Hello  ".trim(); // "Hello"</code></p>
				<p><code>Num -- getSize()</code></p>
				<p>&nbsp;&nbsp; Get the number of characters in a Text. Example: <code>"Hello".getSize(); // 5</code></p>
				<p><code>Text -- substr(Num start)</code></p>
				<p>&nbsp;&nbsp; Cut from the character at the starting index until the end of the Text. A negative start index counts from the end of the Text. Example: <code>"Hello".substr(1); // "ello"</code></p>
				<p><code>Text -- substr(Num start, Num end)</code></p>
				<p>&nbsp;&nbsp; Cut from the character at the starting index until the ending index of the Text. A negative start or ending index counts from the end of the Text. Example: <code>"Hello".substr(1, 3); // "ell"</code></p>
				<p><code>Num? -- parseNum()</code></p>
				<p>&nbsp;&nbsp; Read the Text as if it were a Num. If parsing fails, it will return nothing. Example: <code>"5.5".parseNum(); // 5.5</code></p>
				<p><code>Text? -- charAt(Num)</code></p>
				<p>&nbsp;&nbsp; Get the character at a particular index of the Text, or nothing if the index is longer than the Text. Example: <code>"Hello".charAt(2); // "e"</code></p>
				<p><code>Text[] -- split(Text)</code></p>
				<p>&nbsp;&nbsp; Find each occurence of Text within the target Text, and return the content that separates them in a List. Example: <code>"Foo bar baz".split(" "); // ["Foo", "bar", "baz"]</code></p>
				<p><code>Num? -- indexOf(Text)</code></p>
				<p>&nbsp;&nbsp; Return the index of the first occurence of Text. If it never occurs, return nothing. Example: <code>"Hello".indexOf("l"); // 2</code></p>
				<br/>
				<h3 id="bool">Bool</h3>
				<p><code>Text -- toString()</code></p>
				<p>&nbsp;&nbsp; Convert a Bool into its Text equivalet. Example: <code>true.toString(); // "true"</code></p>
				<br/>
				<h3 id="list">List{T}</h3>
				<p><code>Num -- getSize()</code></p>
				<p>&nbsp;&nbsp; Count the elements in the list. Example: <code>[1, 2].getSize(); // 2</code></p>
				<p><code>Bool -- contains(T)</code></p>
				<p>&nbsp;&nbsp; Check if a particular element exists within a List. Example: <code>[1, 2].contains(2); // true</code></p>
				<p><code>T[] -- intersect(T[])</code></p>
				<p>&nbsp;&nbsp; Keep all elements that exist in both the target List and T[]. Example: <code>[1, 2, 3].intersect([2, 3, 4]); // [2, 3]</code></p>
				<p><code>push(T)</code></p>
				<p>&nbsp;&nbsp; Add an item to the end of a List. Example: <code>Num[].push(2);</code></p>
				<br />
				<h3 id="#Map">- Map{K,V}</h3>
				<p>stub</p>
				<br />
				<h3 id="#printer">- Printer</h3>
				<p>stub</p>
				<br />
				<h3 id="#FileSystem">- FileSystem</h3>
				<p>stub</p>
				<br />
				<h3 id="#FilePath">- FilePath</h3>
				<p>stub</p>
				<br />
				<h3 id="#File">- File</h3>
				<p>stub</p>
				<br />
				<h3 id="#Argv">- Argv</h3>
				<p>stub</p>
				<br />
				<h3 id="#System">- System</h3>
				<p>stub</p>
				<br />
				<br/>
				<h1 id="knownisssues">Known Issues</h1>
				<p>These issues have the potential to crash/corrupt a running program. Some are pretty standard use cases - sorry! And others are pretty obscure/obviously wrong at compile-time.</p>
				<br/>
				<h3 id="optionalarrays">Optional Arrays</h3>
				<p>Before I had optional types, I had list types. When adding optional types I did not consider that they could be combined. Num?[] and Num[]? were parse errors and all was well, albeit incomplete.</p>
				<p>Now I think Num?[] and Num[]? are still parse errors, but at the very least its possible that these types will appear out in the wild through generics, since a class which returns T[] can be instantiated like Class{Num?}.</p>
				<p>Anyways, the end result of this is that a type which is both optional and a lst, acts as both an optional type, and a list. So depending on how it was used and when you call exists {}, its possible to access an index off of nothing, which makes your program explode.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Main is:

    getElementOutOfNothing() {
        var Num?[] = nothing;
        var Num? yourProgramExplodesHere = Num[0];
    }</code></pre>
				<p>This fix is important but also requires essentially rewriting all list or all optional code. So it may be quite a while.</p>
				<br/>
				<h3 id="nestedoptionals">Nested Optionals</h3>
				<p>Another thing I had not considered when implementing optionals is that "null" is an idequate runtime representation of a true optional type system. What can optional types do that nulls can't? Nest, that's what!</p>
			<pre><code class="wake"
>every Main is:

    nestedOptionalsInteractingWithExists() {
        var Num? = nothing;
        var Num?? nested = Num;
        if Num exists { } // this check will fail as it should
        if nested exists { } // this check should succeed, and won't!
    }</code></pre>
				<p>Basically, if you consider a language without optional types, if you had a function that searched through a list and returned either the last item or null, this API is inadequate for a list where the last element <i>is</i> null. The fix isn't too difficult, but optional types need to be stored in recursive wrappers, and unboxed when used within an "exists" check.</p>
				<br/>
				<h3 id="genericprops">Generic Properties</h3>
				<p>When a generic class has a generic type served as a public property, it isn't paramterized the way methods are. The name doesn't change and the type doesn't change either.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Generic{T} is:

    with public T?;

    typeErrors(Generic{Num}) {
        var Num? = Generic.Num; // Doesn't compile: unknown property Num
        var Num? = Generic.T; // Doesn't compile: expected: Num?, actual: T?
        var T? wat = Generic.T; // Successfully compiles: WAT
    }</code></pre>
				<p>This is easy to fix, just low priority. Ping me for a, most likely, same-day fix.</p>
				<br/>
				<h3 id="overlappinggenerics">Overlapping Generics</h3>
				<p>I knew about this issue I'm just a bit scared to really take it on in full. If you have two different types in a generic, you can declare & distinguish two methods by overloading. However, when you later use it with the two types matching, one method or another will quietly overwrite the other.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Generic{A, B} is:

    needs Printer;

    overlappingMethod(A) { Printer.printLine("MethodA"); }
    overlappingMethod(B) { Printer.printLine("MethodB"); }

    oneMethodIsLost(Generic{Num, Num}) {
        Generic.overlappingMethod(5); // prints B...I think...
    }</code></pre>
				<br/>
				<h1 id="missingfeats">Missing Features + Workarounds</h1>
				<p>These missing functionalities should not crash or corrupt any programs, but they may get in the way of your designs. Sorry!</p>
				<br/>
				<h3 id="ctorargs">Constructor Arguments</h3>
				<p>This is a big one!! While wake intended to make struct-like objects excellent to use:</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Person is:

    needs public Text firstname, public Text lastname, public Num age, public Gender;</code></pre>
				<p>Easy! That's it!</p>
				<p>Except, well, you can't supply these values, only the providing class can provide them. I haven't fully decided whether this class, the providing class, or the class using the providing class, should allow and/or require manual ctor argument supplying. If you have been bitten by this in your designs and have any ideas for syntax, keywords, concepts, etc that can solve this problem, send it to me asap!!</p>
				<p>In the meantime, do this dirty hack:</p>
			<pre><code class="wake"
>every PersonProvider is:

    provides Person, Gender; // must provide gender since its a class!
    Person -- getPerson(Text firstname, Text lastname, Num age, Gender) {
        var Person &lt;- this;
        Person.firstname = firstname;
        Person.lastname = lastname;
        Person.age = age;
        Person.Gender = Gender;
    }

every Person is:

    needs public Gender;
    with public Text lastname = ""; // By starting with "", this field doesn't need to be optional
    with public Text firstname = "";
    with public Num age = 0;</code></pre>
				<br/>
				<h3 id="parentmethods">Parent Method Calls</h3>
				<p>This is a semantic analysis and parsing problem. I simply need to look for parent.aMethod() calls and treat them specially. Haven't done it yet. Also, I'm partially waiting on this one because I am pondering two-way-inheritance. There's an easy workaround, though!</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every ParentClass is:

    myMethod() {
        // this is inaccessible from Childclass.myMethod() !!
        // call parent_myMethod from here
	}
    parent_myMethod() { } // since this method IS accessible from both classes

every ChildClass is:

    myMethod() {
        parent.myMethod(); // Won't compile :(
        parent_myMethod(); // so create this method on ParentClass and have fun!
    }</code></pre>
				<br/>
				<h3 id="commonclass">Common Object Class</h3>
				<p>Its useful to have everything (and I mean everything) extend a single class, usually Object. A good example is database queries. It won't be hard to do, but its not done yet.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every FetchUsersQuery is:

    needs PDO;

    getAllUsers(Object[] values) {
        return PDO.prepare("SELECT * FROM user WHERE username = ? AND email = ?", values).find();
    }</code></pre>
				<br/>
				<h3 id="lvaluesexist">Exists on some L-Values</h3>
				<p>For properties on external objects, and potentially other places, you can't use exists because it's very complex to add the value to a scope sym table. You must store it in an intermediate variable, sorry.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Link is:

    with public Link? next;

    cannotCheckExistanceDownChain() {
        if next exists { // OK!
            if next.next exists { }// No bueno!!
            Link? farther = next.next; // OK!
            if farther exists {} // OK!
        }
    }</code></pre>
				<br/>
				<h3 id="namespaces">Namespaces</h3>
				<p>Yeah, just only have so much time. This one will be easy though.</p>
				<br/>
				<h3 id="nothingargs">"Nothing" as an Argument</h3>
				<p>This may be solved more generally eventually. Actually, its closer than ever now that generics have "casing" signatures that get filled in later. But basically, the compiler only finds methods by their signatures rather than their names. Since "nothing" is its own type, it never matches a method signaturee. Luckily you can cast it and achieve the same end.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every MethodCallWithNothng is:

    getAllUsersWith(Text? firstame, Text? lastname) { ... }

    callGetAllUsersWithNothing() {
        getAllUsersWith("ted", nothing); // Won't compile! The compiler can't find the method
        getAllUsersWith("ted", (Text?) nothing); // Now the compiler can find the method :)
    }</code></pre>
				<p>Any big O and little O geeks out there should lend me hand on this one to create a fast binary tree or something. The only way that comes to mind for truly solving this problem would be O of n to the n, I think.</p>
				<br/>
				<h3 id="arrayliterals">List Literals</h3>
				<p>List literals requires Lowest-Common-Ancestor logic to be implemented, which isn't the easiest analysis to implement unfortunately. The only supported list literal is an empty list literal. This gets you far enough but I'll add this later.</p>

			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every DeclareArray is:

    declareArray() {
        Num[] = [1, 2, 3]; // not working yet :(
        Num[] = []; Num[0] = 1; Num[1] = 2; Num[2] = 3; // This will have to do for now
    }</code></pre>

				<h3 id="genericprovs">Generic Provisions</h3>
				<p>Not sure exactly how to put this one. Its a pretty big hole in wake. I'll list the things you can't do, because otherwise its tough to describe.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every GenericProvider{T} is:

    provides T, // won't compile. How can we provide T when T could require any sort of subsequent types?!
         GenericProvider, // This should compile, since all types of GenericProvider have one type of need
         GenericProvider{Num} &lt;- SomeSubclassOfGenericProvider; // It should be possible to do this too, not sure how best to make this happen.

    useAProvider() {
        T &lt;- SomeProvider; // Won't compile, for the same reason as java won't let you do "new T()". Likely will never fix this...its broken for very good reasons.
    }</code></pre>

				<br/>
				<h3 id="genericinheritance">Generic Inheritance</h3>
				<p>This just needs to happen, and its actually not so intimidating a feature. Also may hold up stdlib creation where generic inheritance is crazy.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Set{T} (a Collection{T}) is:</code></pre>
				<br/>
				<h3 id="genericmethods">Generic Methods</h3>
				<p>This is painfully obvious in Asserts. However its quite a difficult item to do...it requires some sweet type inference.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Asserts is:

    {T extends Printable} that(T)Equals($T) {
        if(T != $T) ...
    }</code></pre>
				<p>Also syntax is ugly. What can ya do.</p>
				<br/>
				<h3 id="genericranges">Generic Ranges</h3>
				<p>At the moment all generics operate on any and all types. That is to say, a Generic{T} can be created with absolutely any type. It should be able to set a lower and upper limit. Don't worry, I anticipated this. Shouldn't be too bad once I get around to it.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every Generic{P from Printer, L to Printer} is:

    myMethod(P, L) {
        P.printLine("not possible until 'P from Printer' is allowed.");
        L = P; // Possible since the upper limit of L is a subclass of the lower limit of P :)
    }</code></pre>
				<br/>

				<h3 id="switchcase">Switch/Case</h3>
				<p>Actually, even though it currently parses switch/case like java, I want to revamp it. I have some good ideas but I'm a bit afraid of them, so they're on hold.</p>
				<br/>
				<h3 id="behavioralprovisions">Behavioral Provisions</h3>
				<p>I'm just really not sure how necessary this is! I went years before seeing DI such as this, however, that's partly because of all the "new" spamming. Anyways, its possible, and should be done soon.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every MyProvider is:

    needs App;

    provides User &lt;- { return App.getUser(); }</code></pre>
				<br/>
				<h3 id="abstractprovisions">Abstract Provisions</h3>
				<p>I wasn't entirely sure how typing for providers was going to work. There's still room for a great idea to make providers feel more dynamic. However, in the meantime, this uncertainty clouded my eyes so I didn't think of abstract provisions.</p>
				<p>Essentially, since all classes are interfaces, and pure interface classes simply make all their methods abstract, there needs to be a way to say a class "provides SomeClass" without actually providing anything.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every MyInterface is:
    provides AClass; // Won't compile: need to provide AClass's dependencies.
    // Or, inheritingfrom MyInterface gives you behavior you didn't realize

    myAbstractMethod();
    anotherAbstractMethod();</code></pre>
				<br />
				<h3 id="reflection">Reflection</h3>
				<p>Actually shouldn't be too bad to implement. But its not done yet, and its a big undertaking.</p>
				<br/>
				<h3 id="exceptions">Exceptions</h3>
				<p>Similarly, not too bad to implement actually. However, I am curious about how best to do this. In the meantime, use an Error{V, E} to wrap potential errors and their errortype.</p>
			<span class="label label-info">wake</span>
			<pre><code class="wake"
>every MightBeAnError is:

    needs ErrorProvider;

    Error{User, Text} -- findUser() {
        var Error{User, Text} &lt;- ErrorProvider;
        // do the lookup
        if User exists {
            Error.setSuccess(User);
        } else {
            Error.setError("Could not find user in db");
        }
        return Error;
    }</code></pre>
				<p>This solution runs out when you try to get a User out of an Error that doesn't have one, though!</p>
				<br/>
				<h3 id="enums">Enums</h3>
				<p>Somebody who loves the feature-rich enums of java, and who understands Enum&lt;E extends Enum&lt;E&gt;&gt; should tell me all of the things I need do and not do to make powerful enums.</p>
				<Br />
				<h3 id="recursiveimports">Recursive Imports</h3>
				<p>If two classes use each other, just stick them in one file and you're good. If you split them up into two different files you're screwed!</p>
				<br/>
				</div>
			</div>

		<script src="bootstrap/js/bootstrap.min.js"></script>
	</body>
</html>
